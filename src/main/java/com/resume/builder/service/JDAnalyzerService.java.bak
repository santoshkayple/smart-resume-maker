package com.resume.builder.service;

import com.resume.builder.model.JobDescription;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@Slf4j
public class JDAnalyzerService {

    private static final Set<String> STOP_WORDS = Set.of(
        "a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
        "has", "he", "in", "is", "it", "its", "of", "on", "that", "the",
        "to", "was", "will", "with", "the", "this", "but", "they", "have"
    );

    public JobDescription analyzeJobDescription(String jdText) {
        JobDescription jd = new JobDescription();
        jd.setDescription(jdText);
        
        // Extract job title
        String jobTitle = extractJobTitle(jdText);
        jd.setJobTitle(jobTitle);
        
        // Extract company name (if mentioned)
        String companyName = extractCompanyName(jdText);
        jd.setCompanyName(companyName);
        
        // Extract required skills
        Set<String> requiredSkills = extractSkills(jdText, true);
        jd.setRequiredSkills(String.join(", ", requiredSkills));
        
        // Extract preferred skills
        Set<String> preferredSkills = extractSkills(jdText, false);
        jd.setPreferredSkills(String.join(", ", preferredSkills));
        
        // Extract responsibilities
        String responsibilities = extractResponsibilities(jdText);
        jd.setResponsibilities(responsibilities);
        
        return jd;
    }

    private String extractJobTitle(String text) {
        // Look for common job title patterns
        String[] lines = text.split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.matches("(?i).*(engineer|developer|manager|analyst|designer|consultant|architect).*") 
                && line.length() < 100) {
                return line;
            }
        }
        return "Position";
    }

    private String extractCompanyName(String text) {
        Pattern pattern = Pattern.compile("(?i)(company|organization|at)\\s+([A-Z][a-zA-Z\\s&]+)");
        Matcher matcher = pattern.matcher(text);
        if (matcher.find()) {
            return matcher.group(2).trim();
        }
        return "";
    }

    private Set<String> extractSkills(String text, boolean required) {
        Set<String> skills = new HashSet<>();
        
        // Common technical skills and keywords
        String[] commonSkills = {
            "java", "python", "javascript", "react", "angular", "vue", "node.js", "spring boot",
            "sql", "mysql", "postgresql", "mongodb", "aws", "azure", "docker", "kubernetes",
            "git", "jenkins", "ci/cd", "rest api", "microservices", "agile", "scrum",
            "machine learning", "ai", "data analysis", "html", "css", "typescript",
            "c++", "c#", ".net", "php", "ruby", "go", "kotlin", "swift",
            "redux", "graphql", "webpack", "linux", "unix", "bash"
        };
        
        String lowerText = text.toLowerCase();
        
        // Check for each skill
        for (String skill : commonSkills) {
            if (lowerText.contains(skill.toLowerCase())) {
                skills.add(skill);
            }
        }
        
        // Extract skills from "Required Skills" or "Qualifications" section
        if (required) {
            String requiredSection = extractSectionByKeyword(text, "required", "qualifications", "must have");
            skills.addAll(extractKeywordsFromText(requiredSection));
        } else {
            String preferredSection = extractSectionByKeyword(text, "preferred", "nice to have", "plus");
            skills.addAll(extractKeywordsFromText(preferredSection));
        }
        
        return skills;
    }

    private String extractResponsibilities(String text) {
        String responsibilitiesSection = extractSectionByKeyword(text, 
            "responsibilities", "duties", "you will", "role");
        return responsibilitiesSection;
    }

    private String extractSectionByKeyword(String text, String... keywords) {
        String lowerText = text.toLowerCase();
        
        for (String keyword : keywords) {
            int startIndex = lowerText.indexOf(keyword);
            if (startIndex != -1) {
                int endIndex = findNextSectionStart(lowerText, startIndex + keyword.length());
                if (endIndex == -1) {
                    endIndex = Math.min(startIndex + 1000, text.length());
                }
                return text.substring(startIndex, endIndex).trim();
            }
        }
        
        return "";
    }

    private int findNextSectionStart(String text, int fromIndex) {
        String[] sections = {
            "requirements", "qualifications", "responsibilities", "benefits",
            "about us", "about the company", "equal opportunity"
        };
        
        int minIndex = -1;
        for (String section : sections) {
            int index = text.indexOf(section, fromIndex);
            if (index != -1 && (minIndex == -1 || index < minIndex)) {
                minIndex = index;
            }
        }
        
        return minIndex;
    }

    private Set<String> extractKeywordsFromText(String text) {
        Set<String> keywords = new HashSet<>();
        
        // Split by common delimiters
        String[] words = text.toLowerCase().split("[\\s,;.()\\[\\]{}]+");
        
        for (String word : words) {
            word = word.trim();
            // Filter: not empty, not stop word, length > 2
            if (!word.isEmpty() && !STOP_WORDS.contains(word) && word.length() > 2) {
                keywords.add(word);
            }
        }
        
        return keywords;
    }

    public Set<String> extractAllKeywords(String text) {
        return extractKeywordsFromText(text);
    }
}
