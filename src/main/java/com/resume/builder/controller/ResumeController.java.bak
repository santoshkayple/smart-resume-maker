package com.resume.builder.controller;

import com.resume.builder.dto.MatchScoreDTO;
import com.resume.builder.dto.OptimizationSuggestionDTO;
import com.resume.builder.dto.ResumeDTO;
import com.resume.builder.model.JobDescription;
import com.resume.builder.model.Resume;
import com.resume.builder.repository.JobDescriptionRepository;
import com.resume.builder.repository.ResumeRepository;
import com.resume.builder.service.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/resumes")
@RequiredArgsConstructor
@Slf4j
@CrossOrigin(origins = "*")
public class ResumeController {

    private final ResumeParserService parserService;
    private final ResumeRepository resumeRepository;
    private final MatchingService matchingService;
    private final OptimizationService optimizationService;
    private final PDFGeneratorService pdfGeneratorService;
    private final JobDescriptionRepository jobDescriptionRepository;

    @PostMapping("/upload")
    public ResponseEntity<Resume> uploadResume(@RequestParam("file") MultipartFile file) {
        try {
            log.info("Uploading resume: {}", file.getOriginalFilename());
            Resume resume = parserService.parseResume(file);
            Resume saved = resumeRepository.save(resume);
            return ResponseEntity.ok(saved);
        } catch (IOException e) {
            log.error("Error parsing resume", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping
    public ResponseEntity<List<Resume>> getAllResumes() {
        List<Resume> resumes = resumeRepository.findAllByOrderByUpdatedAtDesc();
        return ResponseEntity.ok(resumes);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Resume> getResume(@PathVariable Long id) {
        return resumeRepository.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}")
    public ResponseEntity<Resume> updateResume(@PathVariable Long id, @RequestBody ResumeDTO resumeDTO) {
        return resumeRepository.findById(id)
            .map(resume -> {
                resume.setName(resumeDTO.getName());
                resume.setEmail(resumeDTO.getEmail());
                resume.setPhone(resumeDTO.getPhone());
                resume.setLinkedIn(resumeDTO.getLinkedin());
                resume.setGithub(resumeDTO.getGithub());
                resume.setSummary(resumeDTO.getSummary());
                resume.setExperience(resumeDTO.getExperience());
                resume.setEducation(resumeDTO.getEducation());
                resume.setSkills(resumeDTO.getSkills());
                resume.setProjects(resumeDTO.getProjects());
                resume.setCertifications(resumeDTO.getCertifications());
                resume.setTemplate(resumeDTO.getTemplate());
                
                Resume updated = resumeRepository.save(resume);
                return ResponseEntity.ok(updated);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteResume(@PathVariable Long id) {
        if (resumeRepository.existsById(id)) {
            resumeRepository.deleteById(id);
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }

    @PostMapping("/{id}/match")
    public ResponseEntity<MatchScoreDTO> matchWithJD(
            @PathVariable Long id,
            @RequestParam Long jdId) {
        
        Resume resume = resumeRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Resume not found"));
        
        JobDescription jd = jobDescriptionRepository.findById(jdId)
            .orElseThrow(() -> new RuntimeException("Job Description not found"));
        
        MatchScoreDTO matchScore = matchingService.calculateMatch(resume, jd);
        
        return ResponseEntity.ok(matchScore);
    }

    @PostMapping("/{id}/optimize")
    public ResponseEntity<Resume> optimizeResume(
            @PathVariable Long id,
            @RequestParam Long jdId) {
        
        Resume resume = resumeRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Resume not found"));
        
        JobDescription jd = jobDescriptionRepository.findById(jdId)
            .orElseThrow(() -> new RuntimeException("Job Description not found"));
        
        Resume optimized = optimizationService.optimizeResume(resume, jd);
        Resume saved = resumeRepository.save(optimized);
        
        return ResponseEntity.ok(saved);
    }

    @GetMapping("/{id}/optimization-suggestions")
    public ResponseEntity<OptimizationSuggestionDTO> getOptimizationSuggestions(
            @PathVariable Long id,
            @RequestParam Long jdId) {
        
        Resume resume = resumeRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Resume not found"));
        
        JobDescription jd = jobDescriptionRepository.findById(jdId)
            .orElseThrow(() -> new RuntimeException("Job Description not found"));
        
        OptimizationSuggestionDTO suggestions = optimizationService.generateOptimizationSuggestions(resume, jd);
        
        return ResponseEntity.ok(suggestions);
    }

    @GetMapping("/{id}/download")
    public ResponseEntity<byte[]> downloadResume(
            @PathVariable Long id,
            @RequestParam(defaultValue = "classic") String template) {
        
        try {
            Resume resume = resumeRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Resume not found"));
            
            byte[] pdfBytes = pdfGeneratorService.generateResumePDF(resume, template);
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PDF);
            headers.setContentDispositionFormData("attachment", 
                resume.getName().replaceAll("\\s+", "_") + "_resume.pdf");
            
            return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);
        } catch (IOException e) {
            log.error("Error generating PDF", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/create")
    public ResponseEntity<Resume> createResume(@RequestBody ResumeDTO resumeDTO) {
        Resume resume = new Resume();
        resume.setName(resumeDTO.getName());
        resume.setEmail(resumeDTO.getEmail());
        resume.setPhone(resumeDTO.getPhone());
        resume.setLinkedIn(resumeDTO.getLinkedin());
        resume.setGithub(resumeDTO.getGithub());
        resume.setSummary(resumeDTO.getSummary());
        resume.setExperience(resumeDTO.getExperience());
        resume.setEducation(resumeDTO.getEducation());
        resume.setSkills(resumeDTO.getSkills());
        resume.setProjects(resumeDTO.getProjects());
        resume.setCertifications(resumeDTO.getCertifications());
        resume.setTemplate(resumeDTO.getTemplate());
        
        Resume saved = resumeRepository.save(resume);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }
}
